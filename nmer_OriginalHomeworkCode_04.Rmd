---
title: "nmer_OriginalHomeworkCode_04"
author: "Nicole Merullo"
date: "2023-10-22"
output:
  prettydoc::html_pretty:
    theme: hpstr
    highlight: github
---

# Homework 4 What's Your Malfunction?
```{r formuoli, echo=FALSE, fig.align='center', out.width='25%'}
knitr::include_graphics('https://media.giphy.com/media/3oz8xUEbvqSrbGuQla/giphy.gif') 
```

Challenges: <br>
1. Telling the formula to do a one sample z test with p2 and n2 as null. I was getting a warning that I needed to use is.null but I thought I still needed to put that after the == for each object. After searching around, I realized it was kind of its own function. <br>
2. Could not figure out how to get the conf.level to vary in the CI part of the formula. Found a way to do this in Module 7. I double checked this worked and what I had for my formula using the Module 10 Challenge 4 example data for a one sample proportion z test. <br>
3. Figuring out the CI for the two sample proportation test was tricky. I used a test from Challenge 5 in Module 10 and broke it down by each component to make sure the formula was working at each part: z statistic, p value, etc. My CI were not quite working out because I tried replacing instances of p1 with p2-p1 from the one sample. Instead, I defined SE for clarity and used pstar. This got me the right values that the Module 10 Challenge 5 answers has.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(curl)
```

## Z.prop.test

-Your function should take the following arguments: p1 and n1 (no default) representing the estimated proportion and sample size (i.e., based on your sample data); p2 and n2 (both defaulting to NULL) that contain a second sample’s proportion and sample size data in the event of a two-sample test; p0 (no default) as the expected value for the population proportion; and alternative (default “two.sided”) and conf.level (default 0.95), to be used in the same way as in the function t.test(). <br>
-When conducting a two-sample test, it should be p1 that is tested as being smaller or larger than p2 when alternative=“less” or alternative=“greater”, the same as in the use of x and y in the function t.test(). <br>
-The function should perform a one-sample Z-test using p1, n1, and p0 if either p2 or n2 (or both) is NULL.<br>
-The function should contain a check for the rules of thumb we have talked about (n∗p>5 and n∗(1−p)>5) to ensure the validity of assuming the normal distribution in both the one- and two-sample settings. If this is violated, the function should still complete but it should also print an appropriate warning message. <br>
-The function should return a list containing the members Z (the test statistic), P (the appropriate p value), and CI (the two-sided CI with respect to “conf.level” around p1 in the case of a one-sample test and around p2-p1 in the case of a two-sample test). For all test alternatives (“two.sided”, “greater”, “less”), calculate symmetric CIs based on quantiles of the normal distribution rather than worrying about calculating single-limit confidence bounds. <br>

```{r formula-1}
Z.prop.test <- function(p0, p1, n1, p2 = NULL, n2 = NULL, alternative = "two.sided", conf.level = 0.95) {}
```


```{r formula-2}
Z.prop.test <- function(p0, p1, n1, p2 = NULL, n2 = NULL, alternative = "two.sided", conf.level = 0.95) 
{
 if (is.null(p2) | is.null(n2)) {
   z <- (p1 - p0)/sqrt(p0*(1 - p0) / n1) #one sample z test
   if (alternative == "greater") {p <- pnorm(z, lower.tail = FALSE)}
   if (alternative == "less") {p <- pnorm(z, lower.tail = TRUE)}
   if (alternative == "two.sided") {
            if (z > 0)
                {
                p <- pnorm(z, lower.tail = FALSE)
                }
            if (z < 0)
                {
                p <- 2 * pnorm(z, lower.tail = TRUE)
            }} #taking the p value with respect to the left tail or the right tail
  upper <- p1 + qnorm(1 - (1 - conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
  lower <- p1 + qnorm((1 - conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
  ci <- c(lower, upper) }
  return(c(z,p, ci))
}
```

```{r test}
Z.prop.test(p0 = 0.8, p1 = 0.6, n1 = 30, alternative = "less")
```

```{r formula-3}
Z.prop.test <- function(p0, p1, n1, p2 = NULL, n2 = NULL, alternative = "two.sided", conf.level = 0.95) 
{
 if (is.null(p2) | is.null(n2)) {
   z <- (p1 - p0)/sqrt(p0*(1 - p0) / n1) #one sample z test
   if (alternative == "greater") {p <- pnorm(z, lower.tail = FALSE)}
   if (alternative == "less") {p <- pnorm(z, lower.tail = TRUE)}
   if (alternative == "two.sided") {
            if (z > 0)
                {
                p <- 2 * pnorm(z, lower.tail = FALSE)
                }
            if (z < 0)
                {
                p <- 2 * pnorm(z, lower.tail = TRUE)
            }} #Adapted from Module 11
  upper <- p1 + qnorm(1 - (1 - conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
  lower <- p1 + qnorm((1 - conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
  ci <- c(lower, upper) }
 else {
   pstar <- (p1+p2)/2 #simplification of the pstar equation from module 10
   z <- (p2 - p1 - p0)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))
    if (alternative == "greater") {p <- pnorm(z, lower.tail = FALSE)}
    if (alternative == "less") {p <- pnorm(z, lower.tail = TRUE)}
    if (alternative == "two.sided") {p <- 1 - pnorm(z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)} #adapted from module 10
   se <- sqrt(pstar * (1-pstar) * (1/n1 + 1/n2))
   upper <- (p2-p1) + qnorm(1 - (1 - conf.level)/2) * se
   lower <- (p2-p1) + qnorm((1 - conf.level)/2) * se
   ci <- c(lower, upper)
 } 
  return(c(z,p, ci))
}
```

```{r test-2}
v1 <- c(1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0,
    1, 0)
n1 <- length(v1)
v2 <- c(1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0,
    0, 1, 1, 0, 1, 1, 1)
n2 = length(v2)
Z.prop.test(p0=0, p1=mean(v1), p2=mean(v2), n1=n1, n2=n2)
```


```{r formula-4}
Z.prop.test <- function(p0, p1, n1, p2 = NULL, n2 = NULL, alternative = "two.sided", conf.level = 0.95) 
{
 if (is.null(p2) | is.null(n2)) {
   if ( (n1 * p1) < 5 | (n1 * (1 - p1)) < 5 ) 
  {print("Warning: This test violates the expectation based on the approximation of the normal")}
   z <- (p1 - p0)/sqrt(p0*(1 - p0) / n1) #one sample z test
   if (alternative == "greater") {p <- pnorm(z, lower.tail = FALSE)}
   if (alternative == "less") {p <- pnorm(z, lower.tail = TRUE)}
   if (alternative == "two.sided") {
            if (z > 0)
                {
                p <- 2 * pnorm(z, lower.tail = FALSE)
                }
            if (z < 0)
                {
                p <- 2 * pnorm(z, lower.tail = TRUE)
            }} #Adapted from Module 11
  upper <- p1 + qnorm(1 - (1 - conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
  lower <- p1 + qnorm((1 - conf.level)/2) * sqrt(p1 * (1 - p1)/n1)
  ci <- c(lower, upper) }
 else {
   if ((n2 * p2) < 5 | (n2 * (1 - p2)) < 5) 
  {print("Warning: This test violates the expectation based on the approximation of the normal")}
   pstar <- (p1+p2)/2 #simplification of the pstar equation from module 10
   z <- (p2 - p1 - p0)/sqrt((pstar * (1 - pstar)) * (1/n1 + 1/n2))
    if (alternative == "greater") {p <- pnorm(z, lower.tail = FALSE)}
    if (alternative == "less") {p <- pnorm(z, lower.tail = TRUE)}
    if (alternative == "two.sided") {p <- 1 - pnorm(z, lower.tail = TRUE) + pnorm(z, lower.tail = FALSE)} #adapted from module 10
   se <- sqrt(pstar * (1-pstar) * (1/n1 + 1/n2))
   upper <- (p2-p1) + qnorm(1 - (1 - conf.level)/2) * se
   lower <- (p2-p1) + qnorm((1 - conf.level)/2) * se
   ci <- c(lower, upper)
 } 
  return(c(z,p,ci))
  }
```

```{r test-3}
Z.prop.test(p0 = 0.8, p1 = 0.6, n1 = 5, alternative = "less")
Z.prop.test(p0=0, p1=0.66, n1=3, p2=0.75, n2=4, alternative = "greater")
```

